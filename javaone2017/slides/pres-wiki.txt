<[autotemplate]
usepackage=[utf8]{inputenc}
usepackage={array,multirow,multicol}
usepackage={textcomp}
usepackage={ragged2e}
usepackage={hyperref}
usepackage={appendixnumberbeamer}
usepackage=[absolute,overlay]{textpos}
hypersetup={colorlinks=false}
documentclass=[aspectratio=169,12pt,xcolor=dvipsnames]{beamer}
title={Marlin renderer, a JDK9 Success Story}
subtitle={Vector Graphics on Steroids for Java 2D and JavaFX}
author={Laurent Bourgès}
institute=[OSUG-DC, CNRS]{ \includegraphics[height=1.6cm,keepaspectratio]{../osug.png} \hspace{20pt} \includegraphics[height=1.3cm,keepaspectratio]{../cnrs.jpg} }
date={JavaOne 2017-10-04}
titleframe=False
usetheme=[inner/subsectionpage=progressbar,outer/numbering=fraction,outer/progressbar=frametitle]{metropolis}
[autotemplate]>
<[nowiki]
\textblockorigin{0pt}{0pt} % position origin (showboxes)


\setbeamercolor{frametitle}{bg=RoyalBlue}
\setbeamercolor{footlineW}{bg=white}

\iftrue
 \setsansfont[BoldFont={Fira Sans SemiBold}]{Fira Sans Book}
\fi

\metroset{block=fill}

\setbeamerfont{block body}{size=\fontsize{9pt}{10.8}}
\setbeamerfont{block title}{size=\fontsize{9pt}{10.8}}




{\setbeamertemplate{background canvas}{ \includegraphics[height=\paperheight, width=\paperwidth]{../javaone-2017.jpg} }
\begin{frame}[plain]
\end{frame}}

{\setbeamertemplate{background canvas}{ \includegraphics[height=\paperheight, width=\paperwidth]{../javaone-marlin.png} }
\begin{frame}[plain]
\end{frame}}




{\setbeamertemplate{logo}{ \includegraphics[height=0.75cm,keepaspectratio]{../openjdk.png} \hspace{20pt} \includegraphics[height=1.5cm,keepaspectratio]{../javaone-logo-fixed.png} \hspace{30pt} }
\frame{\titlepage

\begin{textblock*}{3cm}(12.5cm,0.5cm)
\includegraphics[width=2.5cm,keepaspectratio]{../marlin-logo.png}
\end{textblock*}
}}


\setbeamercolor{footline}{fg=white,bg=RoyalBlue}

\setbeamertemplate{footline}
{%
  \leavevmode%
  \hbox{\begin{beamercolorbox}[wd=.3\paperwidth,ht=2ex,dp=1ex,leftskip=.3cm,rightskip=.3cm plus1fil]{footline}%
    \usebeamerfont{author in head/foot}\insertshortauthor \hspace{2pt} (\insertshortinstitute)
  \end{beamercolorbox}%
  \begin{beamercolorbox}[wd=.45\paperwidth,ht=2ex,dp=1ex,leftskip=.3cm,rightskip=.3cm plus1fil]{footlineW}%
    \usebeamercolor[fg]{normal text}
    \usebeamerfont{title in head/foot}\insertshorttitle
  \end{beamercolorbox}%
  \begin{beamercolorbox}[wd=.25\paperwidth,ht=2ex,dp=1ex,leftskip=.3cm,rightskip=.3cm plus1fil]{footlineW}%
    \usebeamercolor[fg]{normal text}
    \usebeamerfont{title in head/foot}\insertshortdate
    \usebeamerfont{page number in head/foot}
    \usebeamertemplate*{frame footer}
    \hfill
    \usebeamertemplate*{frame numbering}
  \end{beamercolorbox}}%
  \vskip0pt%
}

\makeatletter
\newsavebox{\mybox}
\setbeamertemplate{frametitle}{%
  \nointerlineskip%
  \savebox{\mybox}{%
      \begin{beamercolorbox}[%
          wd=\paperwidth,%
          sep=0pt,%
          leftskip=\metropolis@frametitle@padding,%
          rightskip=\metropolis@frametitle@padding,%
        ]{frametitle}%
      \metropolis@frametitlestrut@start\insertframetitle\metropolis@frametitlestrut@end%
      \end{beamercolorbox}%
    }
  \begin{beamercolorbox}[%
      wd=\paperwidth,%
      sep=0pt,%
      leftskip=\metropolis@frametitle@padding,%
      rightskip=\metropolis@frametitle@padding,%
    ]{frametitle}%
  \metropolis@frametitlestrut@start\insertframetitle\metropolis@frametitlestrut@end%
  \hfill%
    \raisebox{-\metropolis@frametitle@padding}{\includegraphics[height=\dimexpr\ht\mybox+\metropolis@frametitle@padding\relax,keepaspectratio]{../marlin-logo.png}}%
    \hspace*{-\metropolis@frametitle@padding}
  \end{beamercolorbox}%
}

\addtobeamertemplate{frametitle}{}{%
    \usebeamertemplate*{progress bar in head/foot}
}
\makeatother
[nowiki]>




==== Outline ====

\begin{multicols}{2}
  \tableofcontents
\end{multicols}


== Context \& History ==

==== Role of an Antialiasing Renderer ====
* Geometry is defined by a mathematical description of a path
* Shapes may be complex: concave, convex, intersecting ...
* To draw to any kind of raster surface (image, screen), need to map the rendering of ideal path to raster coordinates
* Points on the path may rarely map exactly to raster coordinates
* Need to ascertain coverage (anti-aliasing) for each output pixel

<[nowiki]
\texttt{\small
\begin{tabular}{| c | c | c | c | c | c |}
\hline	
0x0 & 2x2 & 4x4 & 8x8 & 16x16 & 64x64 \\ 
\includegraphics[height=1.8cm,keepaspectratio]{../cropped/crop_0x0.png}
& \includegraphics[height=1.8cm,keepaspectratio]{../cropped/crop_1x1.png}
& \includegraphics[height=1.8cm,keepaspectratio]{../cropped/crop_2x2.png} 
& \includegraphics[height=1.8cm,keepaspectratio]{../cropped/crop_3x3.png}
& \includegraphics[height=1.8cm,keepaspectratio]{../cropped/crop_4x4.png}
& \includegraphics[height=1.8cm,keepaspectratio]{../cropped/crop_6x6.png} \\ \hline
\end{tabular}
}
[nowiki]>




==== Java2D API in a nutshell ====

Java2D is a great \& powerful Graphics API:
* \texttt{Shape} interface (\texttt{java.awt.geom})
** Primitives: \texttt{Rectangle2D, Line2D, Ellipse2D, Arc2D ...}
** General \texttt{Path2D}: \texttt{moveTo(), lineTo(), quadTo(), curveTo(), closeTo()}
* \texttt{Stroke} interface: \texttt{BasicStroke} (\texttt{width, dashes} fields)
* \texttt{Paint} interface: \texttt{Color, GradientPaint, TexturePaint}
* \texttt{Composite} interface: \texttt{AlphaComposite} (Porter/Duff blending rules)
* \texttt{Graphics} interface: \texttt{Graphics2D draw(Shape) or fill(Shape)} performs shape rendering operations




==== Background (before Marlin) ====
Antialiasing renderers available in Java:
* JDK 1.2 included licensed closed-source technology from Ductus
** Ductus provides high performance, but single threaded
** State of the art for its time
** Ductus still ships with Oracle JDK 9
** \texttt{sun.dc.DuctusRenderingEngine} (native C code)

* However OpenJDK 1.6 replaced Ductus with "Pisces"
** Pisces developed + owned by Sun, in part for Java ME
** So could be open-sourced but performance much poorer
** \texttt{java2d.pisces.PiscesRenderingEngine} (java code)

Note: all of these are AA rendering only. Other renderers for non-AA cases.




==== Marlin renderer = OpenJDK's Pisces fork ====

Status in 2013:
* Ductus: faster but scalability issue (multi-threading)
* Pisces: slower but better scalability (GPL) 
* GPU ? Java2D OpenGL \& D3D pipelines provide only few accelerated operations (blending)

* March-Mai 2013: my first patchs to OpenJDK 8:
** Pisces patchs to \url{2d-dev@openjdk.java.net}: too late
** Small interest / few feedbacks
* Andréa Aimé (GeoServer team) pushed me to go on:
** New MapBench tool: serialize \& replay rendering commands
** Fork OpenJDK's Pisces as a new open-source project



==== Marlin renderer @ github ====

 ==> 01/2014: '''Marlin renderer''' \& MapBench projects on github (GPL v2) with only 2 contributors (Me and Andrea Aimé) !

--0.4em--

* \url{https://github.com/bourgesl/marlin-renderer}
** branch 'use\_Unsafe': trunk
** branch 'openjdk': in synch with OpenJDK9
* \url{https://github.com/bourgesl/mapbench}

TODO: add branches


==== Marlin \& MapBench projects @ github ====

Objectives:
* Faster alternative with very good scalability
* Improve rendering quality
* Compatible with both Oracle \& Open JDK 7 / 8 / 9

--0.4em--

'''Very big personal work''':
* Many releases in 2014: see \href{https://github.com/bourgesl/marlin-renderer/releases/}{releases}
* Test Driven Development:
** Regression: MapDisplay (diff pisces / marlin outputs)
** Performance: MapBench \& GeoServer benchmarks (+ oprofile)
* Important feedback within the GIS community (GeoServer) providing complex use cases \& testing releases




==== Marlin Release history @ github ====
* Releases: see \href{https://github.com/bourgesl/marlin-renderer/releases/}{releases}

TODO: table of major features

* Marlin 0.7: improve coordinate rounding arround subpixel center
* Marlin 0.7.2: improve large pixel chunk copies (coverage data)



==== Marlin renderer back into OpenJDK 9 ====

* Late 2014: several mails to \url{2d-dev@openjdk.java.net}
* FOSDEM 2015: discussion with OpenJDK managers (Dalibor \& Mario) on how to contribute the Marlin renderer back

 ==> I joined the graphics-rasterizer project in march 2015 to contribute Marlin as a new standalone renderer for OpenJDK9. 

* '''I worked hard''' (single coder) with Jim Graham \& Phil Race (reviewers) between march 2015 to december 2015 (4 big patches)



==== JEP 265: Marlin renderer back into OpenJDK 9 ====

We proposed the JEP 265 in July 2015 and make it completed !
* JEP 265: Marlin Graphics Renderer
* \href{http://openjdk.java.net/jeps/265}{http://openjdk.java.net/jeps/265}
* Developer : Laurent Bourgès.
* Reviewer  : Jim Graham

* Marlin was integrated in OpenJDK9 b96 (dec 2015) and got enhancements in 2016.
* Current integrated releases within OpenJDK:
** JDK9 = Marlin 0.7.4
** JDK10 = Marlin 0.7.5




==== My feedback on contributing to OpenJDK ====

* Very interesting \& many things learnt
* License issue: OCA for all contributors, no third-party code !
* Webrev process: great but heavy task:
** create webrevs (hg status, webrev.ksh with options)
** push on \url{cr.openjdk.java.net/~<mylogin>/}
** long discussions on mailing lists for my patches (~50 mails)
** timezone issue: delays + no skype
* Few Java2D / computer graphics skills = small field + NO DOC !


==== My feedback on contributing to OpenJDK ====

General:
* Missing contributors into Graphics stack !
* CI: missing 'open' multi-platform machines to perform tests \& benchmarks outside of Oracle
* Funding community-driven effort ? support collaboration with outsiders


== How Marlin works ? ==
==== How the Java2D pipeline works ? ====

Java2D uses only 1 RenderingEngine implementation at runtime:
* SunGraphics2D.draw/fill(shape)
* AAShapePipe.renderPath(shape, stroke)
** aatg = RenderingEngine.getAATileGenerator(shape, at)
*** Coverage mask computation (tiles) as alpha transparency [0-255]
** aatg.getAlpha(byte[] alpha, ...) to get next tile ...
** output pipeline.renderPathTile(byte[] alpha):
*** MaskFill operations (software / OpenGL pipeline) on dest surface

<[code][style=basic, language=java]
RenderingEngine:
    public static synchronized RenderingEngine getInstance();
    public AATileGenerator getAATileGenerator(Shape s, 
				AffineTransform at, ...);
 AATileGenerator:
    public int getTypicalAlpha();
    public void nextTile();
    public void getAlpha(byte tile\[\], ...);
[code]>




==== How Marlin works ? Pisces / Marlin pipeline ====

MarlinRenderingEngine.getAATileGenerator(shape, stroke...):
* use shape.getPathIterator() ==> apply the pipeline to path elements:
* Dasher (optional): 
** generates path dashes (curved or segments)
* Stroker (optional): 
** generates edges arround of every path element
** generates edges for decorations (cap \& joins)
* Renderer:
** curve decimation into line segments
** addLine: basic clipping + convert float to subpixel coordinates
** determine the shape bounding box
** perform edge rendering into tile strides ie compute pixel coverages
** fill the MarlinCache with pixel coverages as byte[] (alpha)
* MarlinTileGenerator:
** provide tile data (32x32) from MarlinCache (packed byte[])




==== How Marlin works ? the AA algorithm ====

* Scanline algorithm [8x8 supersampling] to estimate pixel coverages
= Active Edge table (AET) variant with "java" pointers (integer-based)
* sort edges at each scanline
* estimate subpixel coverage and accumulate in the alpha row
* Once a pixel row is done: copy pixel coverages into cache
* Once 32 (tile height) pixel rows are done: perform blending \& repeat !

<<<../ATAvR.png,height=3.5cm,keepaspectratio>>>
<<<../jsgb-gpu-bg-map.png,height=3cm,keepaspectratio>>>


==== How Marlin works ? the AA algorithm ====
* Java2D's internal drawing renders rectangular tiles.
* Marlin starts with the path defining the shape
* Takes the elements of the path and flattens curves
* Uses 8x8 super-sampling to estimate coverage.
* For each sample line calculates intersections.
* Sorts where the path edges cross the scan line
* Output is one byte per pixel representing alpha coverage.
* Process 32 entire pixel rows at a time and cache sample-line intersection info
* Provide 32x32 rectangular tiles needed by the internal Java2D rendering pipelines


==== Marlin performance optimizations ====
* Initially GC allocation issue:
** Many growing arrays + zero-fill
** Many arrays involved to store edge data, alpha pixel row ...
** Value-Types may be very helpful: manually coded here !
* Marlin RendererContext (TL/CLQ) = reused memory ==> almost no GC
** kept by weak / soft reference
** class instances + initial arrays takes 512Kb
** weak-referenced array cache for larger arrays
* Other considerations: 
** Unsafe: allocate/free memory + less bound checks
** zero-fill (recycle arrays) on used parts only !
** use dirty arrays when possible: C like !




==== Marlin performance optimizations ====
* Need good profiler: use oprofile + gather internal metrics

* Fine tuning of Pisces algorithms:
** Optimized Merge Sort (in-place)
** Custom rounding [float to int]
** DDA in Renderer with correct pixel center handling
** Tile stride approach (32px) instead of all shape mask 
** Pixel alpha transfers (RLE) ==> adaptive approach
** Optimized Pixel copies (block flags)

--0.3em--

A lot more ... 



==== Marlin visual quality (Blind Test) ====[standout]
Who is [Ductus, Pisces, Marlin] ? 
<[nowiki]
\hspace*{-1.0cm}\includegraphics[height=\paperheight-3cm,keepaspectratio]{../test_z_625k-ductus_9.png}
[nowiki]>

==== Marlin visual quality (Blind Test) ====[standout]
Who is [Ductus, Pisces, Marlin] ? 
<[nowiki]
\hspace*{-1.0cm}\includegraphics[height=\paperheight-3cm,keepaspectratio]{../test_z_625k-marlin_9.png}
[nowiki]>

==== Marlin visual quality (Blind Test) ====[standout]
Who is [Ductus, Pisces, Marlin] ? 
<[nowiki]
\hspace*{-1.0cm}\includegraphics[height=\paperheight-3cm,keepaspectratio]{../test_z_625k-pisces_9.png}
[nowiki]>

==== Marlin visual quality (Blind Test) ====[standout]
Answer: Ductus
<[nowiki]
\hspace*{-1.0cm}\includegraphics[height=\paperheight-3cm,keepaspectratio]{../test_z_625k-ductus_9.png}
[nowiki]>

==== Marlin visual quality (Blind Test) ====[standout]
Answer: Marlin
<[nowiki]
\hspace*{-1.0cm}\includegraphics[height=\paperheight-3cm,keepaspectratio]{../test_z_625k-marlin_9.png}
[nowiki]>

==== Marlin visual quality (Blind Test) ====[standout]
Answer: Pisces
<[nowiki]
\hspace*{-1.0cm}\includegraphics[height=\paperheight-3cm,keepaspectratio]{../test_z_625k-pisces_9.png}
[nowiki]>


==== Marlin visual quality (Blind Test) ====[standout]
Who is [Ductus, Pisces, Marlin] ? 

<[nowiki]
\hspace*{-1.225cm}
\begin{tabular}{c c c}
  \includegraphics[height=3cm,keepaspectratio]{../test_z_625k-ductus_9.png} 
& \includegraphics[height=3cm,keepaspectratio]{../test_z_625k-marlin_9.png} 
& \includegraphics[height=3cm,keepaspectratio]{../test_z_625k-pisces_9.png} \\
Ductus & Marlin & Pisces
\end{tabular}
[nowiki]>
 ==> Quite an hard challenge !



== Marlin usage \& benchmarks ==
==== How to use Marlin ? ====

* Just download any Oracle or OpenJDK-9 release
** \url{https://jdk9.java.net/}

--0.4em--

* For JDK 1.7 or JDK-8: 
** Download the latest \href{https://github.com/bourgesl/marlin-renderer/releases/}{Marlin release @ github}
* Howto: \url{https://github.com/bourgesl/marlin-renderer/wiki/How-to-use}
* Start your java program with:
<[code][style=basic, language=bash]
java -Xbootclasspath/a:../lib/marlin-0.7.5-Unsafe.jar
     -Dsun.java2d.renderer=sun.java2d.marlin.MarlinRenderingEngine
     ...
[code]>


==== MapBench benchmarks ====

* MapBench tool:
** Multi-threaded java2d benchmark that replays serialized graphics commands: see \texttt{ShapeDumperGraphics2D}
** Calibration \& warmup phase at startup + correct statistics [95th percentile...]
* Protocol:
** Disable Hyper-Threading (in BIOS)
** Use fixed cpu frequencies (2.0 GHz) on my laptop (i7-6820 HQ)
** Setup JVM: select JDK + basic jvm settings = CMS GC 2Gb Heap
** Use the profile 'shared images' to reduce GC overhead

 ==> Reduce variability (and cpu affinity issues)


==== MapBench tests ====
* Test showcase: 9 maps, 5 large ellipse \& spiral drawings
<[nowiki]
\hspace*{1.0cm}\includegraphics[height=6.5cm,keepaspectratio]{../all.png}
[nowiki]>


=== Comparing AA renderers in JDK-9 (Ductus, Pisces, Marlin) ===

==== Before Marlin (Oracle JDK-9 EA b181) ====
* OracleJDK Ductus (red) \& Pisces (blue)
<[nowiki]
\hspace*{-1.0cm}\includegraphics[width=\paperwidth-1.5cm,keepaspectratio]{../compare-before.png}
[nowiki]>

==== Before Marlin (Oracle JDK-9 EA b181) ====
* OracleJDK Ductus (red) \& Pisces (blue)
<[nowiki]
\hspace*{-1.0cm}\includegraphics[width=\paperwidth-1.5cm,keepaspectratio]{../compare-before.png}
[nowiki]>

\begin{textblock*}{12cm}(2cm,6.35cm)
\begin{block}{Comparison}
* Ductus: faster (1T) but scalability issue !
* Pisces: slower but higher scalability
\end{block}
\end{textblock*}


==== With Marlin (Oracle JDK-9 EA b181) ====
* OracleJDK Ductus (red) \& Pisces (blue) \& Marlin (green)
<[nowiki]
\hspace*{-1.0cm}\includegraphics[width=\paperwidth-1.5cm,keepaspectratio]{../compare-with-marlin.png}
[nowiki]>

==== With Marlin (Oracle JDK-9 EA b181) ====
* OracleJDK Ductus (red) \& Pisces (blue) \& Marlin (green)
<[nowiki]
\hspace*{-1.0cm}\includegraphics[width=\paperwidth-1.5cm,keepaspectratio]{../compare-with-marlin.png}
[nowiki]>

\begin{textblock*}{12cm}(2cm,6.35cm)
\begin{block}{Marlin renderer is the winner}
* Better performance compared to Ductus (or equal) or Pisces
* Perfect scalability
\end{block}
\end{textblock*}


==== Performance gains (1 thread) ====
* Marlin gains over OracleJDK Ductus (red) \& Pisces (blue)
<[nowiki]
\hspace*{-1.0cm}\includegraphics[width=\paperwidth-1.5cm,keepaspectratio]{../compare-with-marlin-gain-1T.png}
[nowiki]>

\begin{textblock*}{12cm}(2cm,6.35cm)
\begin{block}{Marlin performance gains (single thread)}
* vs Ductus: '''10\%''' to 30\%
* vs Pisces: '''125\%''' (average), up to 300\% (stroked spiral test)
\end{block}
\end{textblock*}


==== Performance gains (2 thread) ====
* Marlin gains over OracleJDK Ductus (red) \& Pisces (blue)
<[nowiki]
\hspace*{-1.0cm}\includegraphics[width=\paperwidth-1.5cm,keepaspectratio]{../compare-with-marlin-gain-2T.png}
[nowiki]>

\begin{textblock*}{12cm}(2cm,6.35cm)
\begin{block}{Marlin performance gains (2 threads)}
* vs Ductus: '''75\%''' (average)
* vs Pisces: '''140\%''' (average)
\end{block}
\end{textblock*}


==== Performance gains (4 thread) ====
* Marlin gains over OracleJDK Ductus (red) \& Pisces (blue)
<[nowiki]
\hspace*{-1.0cm}\includegraphics[width=\paperwidth-1.5cm,keepaspectratio]{../compare-with-marlin-gain-4T.png}
[nowiki]>

\begin{textblock*}{12cm}(2cm,6.35cm)
\begin{block}{Marlin performance gains (2 threads)}
* vs Ductus: '''250\%''' (average)
* vs Pisces: '''160\%''' (average)
\end{block}
\end{textblock*}


==== Marlin Performance Summary (JDK-9) ====
* Compared to Ductus:
** Same performance (1T) but better scalability up to 250\% gain (4T)
* Compared to Pisces:
** 2x faster: 100\% to 150\% gain
* Perfect scalability 1T to 4T
<[nowiki]
\hspace*{2.0cm}\includegraphics[height=4cm,keepaspectratio]{../mean-compare-with-marlin-gain.png}
[nowiki]>



=== Comparing Marlin renderer changes between JDK-9 \& OpenJDK-10 ===

==== Marlin Performance changes (JDK-9 vs OpenJDK-10) ====
* Marlin 0.7.5 vs 0.7.4 (curve accuracy, large fills, Double variant)
<[nowiki]
\hspace*{-1.0cm}\includegraphics[width=\paperwidth-1.5cm,keepaspectratio]{../diff-marlin-time.png}
[nowiki]>

==== Marlin Performance changes (JDK-9 vs OpenJDK-10) ====
* Marlin 0.7.5 vs 0.7.4 (curve accuracy, large fills, Double variant)
<[nowiki]
\hspace*{-1.0cm}\includegraphics[width=\paperwidth-1.5cm,keepaspectratio]{../diff-marlin-time.png}
[nowiki]>

\begin{textblock*}{12cm}(2cm,6.35cm)
\begin{block}{Minor timing changes}
* large fills: 10\% faster (large ellipse tests)
* curves: 10\% slower (lots of curves)
\end{block}
\end{textblock*}


==== Marlin Performance Summary (JDK-9 vs OpenJDK-10) ====
* Marlin 0.7.5 vs 0.7.4 (curve accuracy, large fills, Double variant)
<[nowiki]
\hspace*{-1.0cm}\includegraphics[width=\paperwidth-1.5cm,keepaspectratio]{../diff-marlin-gain.png}
[nowiki]>

\begin{textblock*}{12cm}(2cm,6.35cm)
\begin{block}{Same Marlin (average) performance in OpenJDK-10 as in JDK-9}
* Large fills are 10\% faster, improved curve accuracy is only 10\% slower
* '''No difference between Float and Double Marlin variants'''
\end{block}
\end{textblock*}


=== Studying Marlin \& Java2D internal stages ===

==== Marlin internal timings ====
* 3 stages in Java2D pipeline: Path Processing --> Rendering --> Blending
<[nowiki]
\hspace*{-1.0cm}\includegraphics[width=\paperwidth-1.5cm,keepaspectratio]{../pipeline-marlin-gain.png}
[nowiki]>

==== Marlin internal timings ====
* 3 stages in Java2D pipeline: Path Processing --> Rendering --> Blending
<[nowiki]
\hspace*{-1.0cm}\includegraphics[width=\paperwidth-1.5cm,keepaspectratio]{../pipeline-marlin-gain.png}
[nowiki]>

\begin{textblock*}{12cm}(2cm,6.35cm)
\begin{block}{Stage cost ratios}
* Path processing: 20 to 30\% (stroked shapes) but 3\% (filled)
* Blending: '''25\%''' (average) but up to 75\% (large ellipse fills): ''Future work ?'' 
\end{block}
\end{textblock*}


== Marlin renderer tuning ==
==== Marlin renderer tuning ====

Marlin can be customized by using system properties:
* adjust subpixel sampling: 
** X/Y=3: [8x8] (by default)
** smaller values are faster but less accurate
** higher values are slower but more accurate
* pixel sizing: typical largest shape width / height (2048 by default)
* adjust tile size: 6 [64x64] seems better than 5 [32x32]

Debugging:
* log statistics to know what happens
* enable checks if segfault or artefacts !




==== Marlin System properties ====

<[nowiki]
{\small
\begin{table} 
\begin{tabular}{l | c | l}
\hline	
System property \\ {\scriptsize -Dsun.java2d.renderer.<KEY>=} & Values & Description \\ \hline
\hline	
useThreadLocal & \textbf{true} - false & RdrCtx in TL or CLQ (false) \\ \hline
useRef & \textbf{soft} - weak - hard & Reference type to RdrCtx \\ \hline
\hline	
pixelsize & \textbf{2048} in [64-32K] & Typical shape W/H in pixels \\ \hline
subPixel\_log2\_X & \textbf{3} in [1-8] & Subpixel count on X axis \\ \hline
subPixel\_log2\_Y & \textbf{3} in [1-8] & Subpixel count in Y axis \\ \hline
tileSize\_log2 & \textbf{5} in [3-8] & Pixel width/height for tiles \\ \hline
\hline	
doStats & true - \textbf{false} & Log rendering statistics \\ \hline
doChecks & true - \textbf{false} & Perform array checks \\ \hline
useLogger & true - \textbf{false} & Use j.u.l.Logger \\ \hline
\end{tabular}
\end{table}
}
[nowiki]>

Log-2 values for subpixel \& tile sizes:
* subPixel = 3 means 8 x 8 
* tileSize = 5 means 32 x 32




==== Other Java 9 improvements ====
JDK-9 bug fixes from \href{http://bugs.openjdk.java.net}{http://bugs.openjdk.java.net}
* \href{https://bugs.openjdk.java.net/browse/JDK-6488522}{JDK-6488522} '''PNG writer''' should permit setting compression level and iDAT chunk maximum size --> '''set compression level to medium''' [4 vs 9]

* \href{https://bugs.openjdk.java.net/browse/JDK-8078464}{JDK-8078464} '''Path2D storage growth algorithms should be less linear'''
* \href{https://bugs.openjdk.java.net/browse/JDK-8084662}{JDK-8084662} Path2D copy constructors and clone method propagate size of arrays from source path 
* \href{https://bugs.openjdk.java.net/browse/JDK-8074587}{JDK-8074587} Path2D copy constructors do not trim arrays 
* \href{https://bugs.openjdk.java.net/browse/JDK-8078192}{JDK-8078192} Path2D storage trimming 
* \href{https://bugs.openjdk.java.net/browse/JDK-8169294}{JDK-8169294} JFX Path2D storage growth algorithms should be less linear 



== MarlinFX ==

==== MarlinFX project ====

2016: port Marlin into JavaFX Prism
* Prism integration
** Complete mask no more tiles
** GPU backend is faster (upload texture may be costly)
** but single-threaded (GUI)

* Double-precision variant to improve accuracy on very large shapes (stroke / dashes)

* Integrated in OpenJFX9 (dec 2016) but disabled by default


==== MarlinFX System properties ====
'sun.java2d.marlin' prefix --> 'javafx.prism.marlin' prefix

TODO: complete


==== My feedback on contributing to OpenJFX ====

Contrary to Marlin, OpenJFX patches were more quickly integrated into OpenJFX9 (Jim Graham, again) !

TODO: complete


== MarlinFX usage \& benchmarks ==

==== How to use MarlinFX ? ====
 MarlinFX is only available in JDK-9:
* Enable MarlinFX using prism settings:
<[code][style=basic, language=bash]
java -Dprism.marlinrasterizer=true ...
[code]>* Select Marlin Double or Float variant:
<[code][style=basic, language=bash]
java -Dprism.marlinrasterizer=true -Dprism.marlin.double=true ...
[code]>* To enable the Prism log, add \texttt{-Dprism.verbose=true}:
<[code][style=basic, language=bash]
Prism pipeline init order: es2 
Using Marlin rasterizer (double)
[code]>


==== DemoFX benchmarks ====
* OpenJFX9 b146 first results with DemoFX Triangle test (VSYNC)
** '''58 fps vs 48 fps = 20\% gain''' <<<../chris_demoFX_marlinFX9.png,height=6cm,keepaspectratio>>>


==== MapBenchFX benchmarks ====

* MapBenchFX: JavaFX application to render maps
* Port of the Java2D benchmark using FXGraphics2D

<[nowiki]
\begin{tabular}{c c c}
  \includegraphics[height=2.5cm,keepaspectratio]{../MapDemo-FX_circles.png} 
& \includegraphics[height=2.5cm,keepaspectratio]{../MapDemo-FX_map_dc.png} 
& \includegraphics[height=2.5cm,keepaspectratio]{../MapDemo-FX_map_z625k.png} 
\end{tabular}
[nowiki]>


==== MarlinFX vs Native \& Java Pisces (Oracle JDK-9 EA b181) ====
* Native Pisces (red) \& Java Pisces (blue) \& MarlinFX (green)
<[nowiki]
\hspace*{-1.0cm}\includegraphics[width=\paperwidth-1.5cm,keepaspectratio]{../fx9-marlin.png}
[nowiki]>

==== MarlinFX vs Native \& Java Pisces (Oracle JDK-9 EA b181) ====
* Native Pisces (red) \& Java Pisces (blue) \& MarlinFX (green)
<[nowiki]
\hspace*{-1.0cm}\includegraphics[width=\paperwidth-1.5cm,keepaspectratio]{../fx9-marlin-gain.png}
[nowiki]>

\begin{textblock*}{12cm}(2cm,6.35cm)
\begin{block}{MarlinFX renderer is the winner (on linux) }
* vs Native Pisces: '''65\%''' (average)
* vs Java Pisces: '''70\%''' (average)
\end{block}
\end{textblock*}


== Future work ==
==== Future work ====

I may have still spare time to improve Marlin...

--1em--

But your help is needed:
* Try your applications \& use cases with the Marlin renderer
* Contribute to the Marlin project: let's implement new algorithms (gamma correction, clipping ...)
* Provide feedback, please !




==== Quality Ideas ====
* '''Handle properly the gamma correction''': 
** in MaskFill for images (C macros) \& GPU backends
** '''Very important for visual quality'''
** note: Stroke's width must compensate the gamma correction to avoid having thiner / fatter shapes.

<<<../LinesTest-original-maskFill-crop.png,height=2.25cm,keepaspectratio>>> \hspace{4pt}
<<<../LinesTest-gamma-corrected-maskFill-crop.png,height=2.25cm,keepaspectratio>>>

==== Quality Ideas ====
* Analytical pixel coverage: using signed area coverage for a trapezoid ==> compute the exact pixel area covered by the polygon
\centering
<<<../PolygonFillTrapezoidExample.png,height=4.5cm,keepaspectratio>>>




==== Performance ideas ====

* Clipping (coming in release 0.8): 
** implement early efficient path clipping (major impact on dashes)
** take care of affine transforms (margin, not always rectangle)

* Cap \& join processing (Stroker): 
** do not emit extra collinear points for squared cap \& miter joins
** improve Polygon Simplifier ?

* Scanline processing (8x8 subpixels):
** 8 scanlines per pixel row ==> compute exact area covered in 1 row
** see algorithmic approach (AGG like): \url{http://nothings.org/gamedev/rasterize/}
** may be almost as fast but a lot more precise !




==== EA Marlin 0.8.1 = Path clipping ====

<[nowiki]
\hspace*{-0.25cm}\includegraphics[width=\paperwidth-1.5cm,keepaspectratio]{../clip-marlin-time.png}
[nowiki]>

==== EA Marlin 0.8.1 = Path clipping ====

<[nowiki]
\hspace*{-0.25cm}\includegraphics[width=\paperwidth-1.5cm,keepaspectratio]{../clip-marlin-gain.png}
[nowiki]>



== Conclusion ==
==== Conclusion ====
* Marlin rocks in Java 9!
* Performance goals were met
** Scales for multiple threads whereas Ductus does not
** Single threaded performance generally as good or better for complex shapes.
* Quality goals were met.
* Marlin is now the default AA renderer for Oracle JDK (and OpenJDK).
* Implementation, not API. Benefit accrues automatically to apps.


==== That's all folks ! ====

* Please ask your questions 
* or send them to \url{marlin-renderer@googlegroups.com}

--0.6em--

Special thanks to:
* Andréa Aimé \& GeoServer team
* OpenJDK teams for their help, reviews \& support: 
** Jim Graham \& Phil Race (Java2D)
** Mario Torre \& Dalibor Topic
** Mark Reinhold
* ALL Marlin users


==== JavaOne Sponsors (gofundme) ====
Special Thanks to all my donators:
<[columns]
[[[0.56\textwidth]]]
* '''GeoServer Project Steering Comittee'''
* '''Gluon Software'''
** Thanks for all that you do to make JavaFX an awesome UI library
* '''Dirk Lemmermann'''
** What would I do without people like you? So here you go!
[[[0.48\textwidth]]]
* '''AZUL SYSTEMS'''
* '''OpenJDK''' members: \\ '''Mark Reinhold, !Jim Graham!, \\ Phil Race, Kevin Rushforth'''
* '''Manuel Timita'''
** Your work means a lot to us!
* H. K.
[columns]>

==== JavaOne Sponsors (gofundme) ====
* !'''Andréa Aimé'''!
** Laurent helped solving a significant performance/scalability problem in server side Java applications using java2d. Let's help him reach JavaOne and talk about his work!
* '''Chris Newland'''
** Laurent has made a big contribution to OpenJDK with his Marlin and Marlin-FX high performance renderers. Let's help him get to JavaOne 2017!
<[columns]
[[[0.4\textwidth]]]
* '''Simone Giannecchini'''
* Z. B.
* '''JUGS e.V.'''
[[[0.6\textwidth]]]
* Brad Hards
* Mario Ivankovits
* Peter-Paul Koonings (GeoNovation)
[columns]>



==== JavaOne Sponsors (gofundme) ====
<[columns]
[[[0.5\textwidth]]]
* '''Michael Paus'''
* Bart van den Eijnden (osgis.nl)
* Mario Zechner
* Jody Garnett
* Tom Schindl
* Thea Aldrich
* Cédric Champeau
* Ondrej Mihályi
* Thomas Enebo
* Hiroshi Nakamura
[[[0.5\textwidth]]]
* Reinhard Pointner
* Adler Fleurant
* Paul Bramy
* Sten Nordström
* Chris Holmes
* Michael Simons
* P. S.
* A. B.
* Igor Kolomiets
* Vincent Privat
[columns]>


==== JavaOne Sponsors (gofundme) ====
* Carl Dea
** I'm not going to JavaOne, but hearing about Laurent Bourgès making Java 2D faster caught my attention. Graphics and performance engineers are true heroes. They make users of the APIs look good, while their work under the covers really do the heavy lifting. Go Laurent!
* Mike Duigou
** Would love to see JavaOne sponsor opensource committers in future years
* M. H.
* J. M.


== ==[Extra]

<[nowiki]
\appendix

\setbeamertemplate{footline}
{%
  \leavevmode%
  \hbox{\begin{beamercolorbox}[wd=.3\paperwidth,ht=2ex,dp=1ex,leftskip=.3cm,rightskip=.3cm plus1fil]{footline}%
    \usebeamerfont{author in head/foot}\insertshortauthor \hspace{2pt} (\insertshortinstitute)
  \end{beamercolorbox}%
  \begin{beamercolorbox}[wd=.45\paperwidth,ht=2ex,dp=1ex,leftskip=.3cm,rightskip=.3cm plus1fil]{footlineW}%
    \usebeamercolor[fg]{normal text}
    \usebeamerfont{title in head/foot}\insertshorttitle
  \end{beamercolorbox}%
  \begin{beamercolorbox}[wd=.25\paperwidth,ht=2ex,dp=1ex,leftskip=.3cm,rightskip=.3cm plus1fil]{footlineW}%
    \usebeamercolor[fg]{normal text}
    \usebeamerfont{title in head/foot}\insertshortdate
  \end{beamercolorbox}}%
  \vskip0pt%
}

\makeatletter
\newsavebox{\myboxB}
\setbeamertemplate{frametitle}{%
  \nointerlineskip%
  \savebox{\myboxB}{%
      \begin{beamercolorbox}[%
          wd=\paperwidth,%
          sep=0pt,%
          leftskip=\metropolis@frametitle@padding,%
          rightskip=\metropolis@frametitle@padding,%
        ]{frametitle}%
      \metropolis@frametitlestrut@start\insertframetitle\metropolis@frametitlestrut@end%
      \end{beamercolorbox}%
    }
  \begin{beamercolorbox}[%
      wd=\paperwidth,%
      sep=0pt,%
      leftskip=\metropolis@frametitle@padding,%
      rightskip=\metropolis@frametitle@padding,%
    ]{frametitle}%
  \metropolis@frametitlestrut@start\insertframetitle\metropolis@frametitlestrut@end%
  \hfill%
    \raisebox{-\metropolis@frametitle@padding}{\includegraphics[height=\dimexpr\ht\myboxB+\metropolis@frametitle@padding\relax,keepaspectratio]{../marlin-logo.png}}%
    \hspace*{-\metropolis@frametitle@padding}
  \end{beamercolorbox}%
}

\addtobeamertemplate{frametitle}{}{%
    \usebeamertemplate*{progress bar in head/foot}
}
\makeatother
[nowiki]>


=== Comparing Marlin renderer releases using JDK-8 ===

==== Marlin Performance evolution between 0.3 \& 0.8.1 (JDK-8) ====
* Marlin 0.3 (2014.1) \& 0.5.6 (2015) \& 0.7.4 (JDK-9) \& 0.8.1 (2017)
<[nowiki]
\hspace*{-1.0cm}\includegraphics[width=\paperwidth-1.5cm,keepaspectratio]{../release-marlin-time.png}
[nowiki]>

==== Marlin Performance evolution between 0.3 \& 0.8.1 (JDK-8) ====
* Marlin 0.5.6 \& 0.7.4 \& 0.8.1 vs 0.3
<[nowiki]
\hspace*{-1.0cm}\includegraphics[width=\paperwidth-1.5cm,keepaspectratio]{../release-marlin-gain.png}
[nowiki]>

\begin{textblock*}{12cm}(2cm,6.35cm)
\begin{block}{Marlin performance improved through releases}
* Loss in 0.5.6 (large ellipse fills) fixed in 0.7
* Important improvements on complex stroked shapes (spirals)
\end{block}
\end{textblock*}


=== Performance impact of the subpixel tuning ===
==== Performance impact of the subpixel tuning ====
* Subpixel settings (1x1 to 6x6):
<[nowiki]
\hspace*{-1.cm}\includegraphics[width=\paperwidth-1.5cm,keepaspectratio]{../subpixel-marlin-time.png}
[nowiki]>

==== Performance impact of the subpixel tuning ====
* Gain \& Loss of Subpixel settings (1x1 to 6x6) VS 3x3:
<[nowiki]
\hspace*{-1cm}\includegraphics[width=\paperwidth-1.5cm,keepaspectratio]{../subpixel-marlin-gain.png}
[nowiki]>



